{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, Inject, EventEmitter, Directive, Input, Output, NgModule } from '@angular/core';\nimport { BehaviorSubject, of, from, merge, forkJoin } from 'rxjs';\nimport { map, switchMap, catchError, mergeAll, first, mergeMap, every, skip, take, tap } from 'rxjs/operators';\nimport * as i3 from '@angular/router';\nconst NgxPermissionsPredefinedStrategies = {\n  REMOVE: 'remove',\n  SHOW: 'show'\n};\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\nfunction isPlainObject(value) {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false;\n  } else {\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.prototype;\n  }\n}\n\nfunction isString(value) {\n  return !!value && typeof value === 'string';\n}\n\nfunction isBoolean(value) {\n  return typeof value === 'boolean';\n}\n\nfunction isPromise(promise) {\n  return Object.prototype.toString.call(promise) === '[object Promise]';\n}\n\nfunction notEmptyValue(value) {\n  if (Array.isArray(value)) {\n    return value.length > 0;\n  }\n\n  return !!value;\n}\n\nfunction transformStringToArray(value) {\n  if (isString(value)) {\n    return [value];\n  }\n\n  return value;\n}\n\nclass NgxPermissionsStore {\n  constructor() {\n    this.permissionsSource = new BehaviorSubject({});\n    this.permissions$ = this.permissionsSource.asObservable();\n  }\n\n}\n\nNgxPermissionsStore.ɵfac = function NgxPermissionsStore_Factory(t) {\n  return new (t || NgxPermissionsStore)();\n};\n\nNgxPermissionsStore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxPermissionsStore,\n  factory: NgxPermissionsStore.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsStore, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n\nconst USE_PERMISSIONS_STORE = new InjectionToken('USE_PERMISSIONS_STORE');\n\nclass NgxPermissionsService {\n  constructor(isolate = false, permissionsStore) {\n    this.isolate = isolate;\n    this.permissionsStore = permissionsStore;\n    this.permissionsSource = isolate ? new BehaviorSubject({}) : permissionsStore.permissionsSource;\n    this.permissions$ = this.permissionsSource.asObservable();\n  }\n  /**\n   * Remove all permissions from permissions source\n   */\n\n\n  flushPermissions() {\n    this.permissionsSource.next({});\n  }\n\n  hasPermission(permission) {\n    if (!permission || Array.isArray(permission) && permission.length === 0) {\n      return Promise.resolve(true);\n    }\n\n    permission = transformStringToArray(permission);\n    return this.hasArrayPermission(permission);\n  }\n\n  loadPermissions(permissions, validationFunction) {\n    const newPermissions = permissions.reduce((source, name) => this.reducePermission(source, name, validationFunction), {});\n    this.permissionsSource.next(newPermissions);\n  }\n\n  addPermission(permission, validationFunction) {\n    if (Array.isArray(permission)) {\n      const permissions = permission.reduce((source, name) => this.reducePermission(source, name, validationFunction), this.permissionsSource.value);\n      this.permissionsSource.next(permissions);\n    } else {\n      const permissions = this.reducePermission(this.permissionsSource.value, permission, validationFunction);\n      this.permissionsSource.next(permissions);\n    }\n  }\n\n  removePermission(permissionName) {\n    const permissions = { ...this.permissionsSource.value\n    };\n    delete permissions[permissionName];\n    this.permissionsSource.next(permissions);\n  }\n\n  getPermission(name) {\n    return this.permissionsSource.value[name];\n  }\n\n  getPermissions() {\n    return this.permissionsSource.value;\n  }\n\n  reducePermission(source, name, validationFunction) {\n    if (!!validationFunction && isFunction(validationFunction)) {\n      return { ...source,\n        [name]: {\n          name,\n          validationFunction\n        }\n      };\n    }\n\n    return { ...source,\n      [name]: {\n        name\n      }\n    };\n  }\n\n  hasArrayPermission(permissions) {\n    const promises = permissions.map(key => {\n      if (this.hasPermissionValidationFunction(key)) {\n        const validationFunction = this.permissionsSource.value[key].validationFunction;\n        const immutableValue = { ...this.permissionsSource.value\n        };\n        return of(null).pipe(map(() => validationFunction(key, immutableValue)), switchMap(promise => isBoolean(promise) ? of(promise) : promise), catchError(() => of(false)));\n      } // check for name of the permission if there is no validation function\n\n\n      return of(!!this.permissionsSource.value[key]);\n    });\n    return from(promises).pipe(mergeAll(), first(data => data !== false, false), map(data => data !== false)).toPromise().then(data => data);\n  }\n\n  hasPermissionValidationFunction(key) {\n    return !!this.permissionsSource.value[key] && !!this.permissionsSource.value[key].validationFunction && isFunction(this.permissionsSource.value[key].validationFunction);\n  }\n\n}\n\nNgxPermissionsService.ɵfac = function NgxPermissionsService_Factory(t) {\n  return new (t || NgxPermissionsService)(i0.ɵɵinject(USE_PERMISSIONS_STORE), i0.ɵɵinject(NgxPermissionsStore));\n};\n\nNgxPermissionsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxPermissionsService,\n  factory: NgxPermissionsService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [USE_PERMISSIONS_STORE]\n      }]\n    }, {\n      type: NgxPermissionsStore\n    }];\n  }, null);\n})();\n\nclass NgxPermissionsConfigurationStore {\n  constructor() {\n    this.strategiesSource = new BehaviorSubject({});\n    this.strategies$ = this.strategiesSource.asObservable();\n  }\n\n}\n\nNgxPermissionsConfigurationStore.ɵfac = function NgxPermissionsConfigurationStore_Factory(t) {\n  return new (t || NgxPermissionsConfigurationStore)();\n};\n\nNgxPermissionsConfigurationStore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxPermissionsConfigurationStore,\n  factory: NgxPermissionsConfigurationStore.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsConfigurationStore, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n\nconst USE_CONFIGURATION_STORE = new InjectionToken('USE_CONFIGURATION_STORE');\n\nclass NgxPermissionsConfigurationService {\n  constructor(isolate = false, configurationStore) {\n    this.isolate = isolate;\n    this.configurationStore = configurationStore;\n    this.strategiesSource = this.isolate ? new BehaviorSubject({}) : this.configurationStore.strategiesSource;\n    this.strategies$ = this.strategiesSource.asObservable();\n    this.onAuthorisedDefaultStrategy = this.isolate ? undefined : this.configurationStore.onAuthorisedDefaultStrategy;\n    this.onUnAuthorisedDefaultStrategy = this.isolate ? undefined : this.configurationStore.onUnAuthorisedDefaultStrategy;\n  }\n\n  setDefaultOnAuthorizedStrategy(name) {\n    if (this.isolate) {\n      this.onAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n    } else {\n      this.configurationStore.onAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n      this.onAuthorisedDefaultStrategy = this.configurationStore.onAuthorisedDefaultStrategy;\n    }\n  }\n\n  setDefaultOnUnauthorizedStrategy(name) {\n    if (this.isolate) {\n      this.onUnAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n    } else {\n      this.configurationStore.onUnAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n      this.onUnAuthorisedDefaultStrategy = this.configurationStore.onUnAuthorisedDefaultStrategy;\n    }\n  }\n\n  addPermissionStrategy(key, func) {\n    this.strategiesSource.value[key] = func;\n  }\n\n  getStrategy(key) {\n    return this.strategiesSource.value[key];\n  }\n\n  getAllStrategies() {\n    return this.strategiesSource.value;\n  }\n\n  getDefinedStrategy(name) {\n    if (this.strategiesSource.value[name] || this.isPredefinedStrategy(name)) {\n      return name;\n    } else {\n      throw new Error(`No ' ${name} ' strategy is found please define one`);\n    }\n  }\n\n  isPredefinedStrategy(strategy) {\n    return strategy === NgxPermissionsPredefinedStrategies.SHOW || strategy === NgxPermissionsPredefinedStrategies.REMOVE;\n  }\n\n}\n\nNgxPermissionsConfigurationService.ɵfac = function NgxPermissionsConfigurationService_Factory(t) {\n  return new (t || NgxPermissionsConfigurationService)(i0.ɵɵinject(USE_CONFIGURATION_STORE), i0.ɵɵinject(NgxPermissionsConfigurationStore));\n};\n\nNgxPermissionsConfigurationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxPermissionsConfigurationService,\n  factory: NgxPermissionsConfigurationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsConfigurationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [USE_CONFIGURATION_STORE]\n      }]\n    }, {\n      type: NgxPermissionsConfigurationStore\n    }];\n  }, null);\n})();\n\nclass NgxRolesStore {\n  constructor() {\n    this.rolesSource = new BehaviorSubject({});\n    this.roles$ = this.rolesSource.asObservable();\n  }\n\n}\n\nconst USE_ROLES_STORE = new InjectionToken('USE_ROLES_STORE');\n\nclass NgxRolesService {\n  constructor(isolate = false, rolesStore, permissionsService) {\n    this.isolate = isolate;\n    this.rolesStore = rolesStore;\n    this.permissionsService = permissionsService;\n    this.rolesSource = this.isolate ? new BehaviorSubject({}) : this.rolesStore.rolesSource;\n    this.roles$ = this.rolesSource.asObservable();\n  }\n\n  addRole(name, validationFunction) {\n    const roles = { ...this.rolesSource.value,\n      [name]: {\n        name,\n        validationFunction\n      }\n    };\n    this.rolesSource.next(roles);\n  }\n\n  addRoleWithPermissions(name, permissions) {\n    this.permissionsService.addPermission(permissions);\n    this.addRole(name, permissions);\n  }\n\n  addRoles(rolesObj) {\n    Object.keys(rolesObj).forEach((key, index) => {\n      this.addRole(key, rolesObj[key]);\n    });\n  }\n\n  addRolesWithPermissions(rolesObj) {\n    Object.keys(rolesObj).forEach((key, index) => {\n      this.addRoleWithPermissions(key, rolesObj[key]);\n    });\n  }\n\n  flushRoles() {\n    this.rolesSource.next({});\n  }\n\n  flushRolesAndPermissions() {\n    this.flushRoles();\n    this.permissionsService.flushPermissions();\n  }\n\n  removeRole(roleName) {\n    const roles = { ...this.rolesSource.value\n    };\n    delete roles[roleName];\n    this.rolesSource.next(roles);\n  }\n\n  getRoles() {\n    return this.rolesSource.value;\n  }\n\n  getRole(name) {\n    return this.rolesSource.value[name];\n  }\n\n  hasOnlyRoles(names) {\n    const isNamesEmpty = !names || Array.isArray(names) && names.length === 0;\n\n    if (isNamesEmpty) {\n      return Promise.resolve(true);\n    }\n\n    names = transformStringToArray(names);\n    return Promise.all([this.hasRoleKey(names), this.hasRolePermission(this.rolesSource.value, names)]).then(([hasRoles, hasPermissions]) => {\n      return hasRoles || hasPermissions;\n    });\n  }\n\n  hasRoleKey(roleName) {\n    const promises = roleName.map(key => {\n      const hasValidationFunction = !!this.rolesSource.value[key] && !!this.rolesSource.value[key].validationFunction && isFunction(this.rolesSource.value[key].validationFunction);\n\n      if (hasValidationFunction && !isPromise(this.rolesSource.value[key].validationFunction)) {\n        const validationFunction = this.rolesSource.value[key].validationFunction;\n        const immutableValue = { ...this.rolesSource.value\n        };\n        return of(null).pipe(map(() => validationFunction(key, immutableValue)), switchMap(promise => isBoolean(promise) ? of(promise) : promise), catchError(() => of(false)));\n      }\n\n      return of(false);\n    });\n    return from(promises).pipe(mergeAll(), first(data => data !== false, false), map(data => data !== false)).toPromise().then(data => data);\n  }\n\n  hasRolePermission(roles, roleNames) {\n    return from(roleNames).pipe(mergeMap(key => {\n      if (roles[key] && Array.isArray(roles[key].validationFunction)) {\n        return from(roles[key].validationFunction).pipe(mergeMap(permission => this.permissionsService.hasPermission(permission)), every(hasPermission => hasPermission === true));\n      }\n\n      return of(false);\n    }), first(hasPermission => hasPermission === true, false)).toPromise();\n  }\n\n}\n\nNgxRolesService.ɵfac = function NgxRolesService_Factory(t) {\n  return new (t || NgxRolesService)(i0.ɵɵinject(USE_ROLES_STORE), i0.ɵɵinject(NgxRolesStore), i0.ɵɵinject(NgxPermissionsService));\n};\n\nNgxRolesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxRolesService,\n  factory: NgxRolesService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxRolesService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [USE_ROLES_STORE]\n      }]\n    }, {\n      type: NgxRolesStore\n    }, {\n      type: NgxPermissionsService\n    }];\n  }, null);\n})();\n\nclass NgxPermissionsDirective {\n  constructor(permissionsService, configurationService, rolesService, viewContainer, changeDetector, templateRef) {\n    this.permissionsService = permissionsService;\n    this.configurationService = configurationService;\n    this.rolesService = rolesService;\n    this.viewContainer = viewContainer;\n    this.changeDetector = changeDetector;\n    this.templateRef = templateRef;\n    this.permissionsAuthorized = new EventEmitter();\n    this.permissionsUnauthorized = new EventEmitter(); // skip first run cause merge will fire twice\n\n    this.firstMergeUnusedRun = 1;\n  }\n\n  ngOnInit() {\n    this.viewContainer.clear();\n    this.initPermissionSubscription = this.validateExceptOnlyPermissions();\n  }\n\n  ngOnChanges(changes) {\n    const onlyChanges = changes.ngxPermissionsOnly;\n    const exceptChanges = changes.ngxPermissionsExcept;\n\n    if (onlyChanges || exceptChanges) {\n      // Due to bug when you pass empty array\n      if (onlyChanges && onlyChanges.firstChange) {\n        return;\n      }\n\n      if (exceptChanges && exceptChanges.firstChange) {\n        return;\n      }\n\n      merge(this.permissionsService.permissions$, this.rolesService.roles$).pipe(skip(this.firstMergeUnusedRun), take(1)).subscribe(() => {\n        if (notEmptyValue(this.ngxPermissionsExcept)) {\n          this.validateExceptAndOnlyPermissions();\n          return;\n        }\n\n        if (notEmptyValue(this.ngxPermissionsOnly)) {\n          this.validateOnlyPermissions();\n          return;\n        }\n\n        this.handleAuthorisedPermission(this.getAuthorisedTemplates());\n      });\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.initPermissionSubscription) {\n      this.initPermissionSubscription.unsubscribe();\n    }\n  }\n\n  validateExceptOnlyPermissions() {\n    return merge(this.permissionsService.permissions$, this.rolesService.roles$).pipe(skip(this.firstMergeUnusedRun)).subscribe(() => {\n      if (notEmptyValue(this.ngxPermissionsExcept)) {\n        this.validateExceptAndOnlyPermissions();\n        return;\n      }\n\n      if (notEmptyValue(this.ngxPermissionsOnly)) {\n        this.validateOnlyPermissions();\n        return;\n      }\n\n      this.handleAuthorisedPermission(this.getAuthorisedTemplates());\n    });\n  }\n\n  validateExceptAndOnlyPermissions() {\n    Promise.all([this.permissionsService.hasPermission(this.ngxPermissionsExcept), this.rolesService.hasOnlyRoles(this.ngxPermissionsExcept)]).then(([hasPermission, hasRole]) => {\n      if (hasPermission || hasRole) {\n        this.handleUnauthorisedPermission(this.ngxPermissionsExceptElse || this.ngxPermissionsElse);\n        return;\n      }\n\n      if (!!this.ngxPermissionsOnly) {\n        throw false;\n      }\n\n      this.handleAuthorisedPermission(this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef);\n    }).catch(() => {\n      if (!!this.ngxPermissionsOnly) {\n        this.validateOnlyPermissions();\n      } else {\n        this.handleAuthorisedPermission(this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef);\n      }\n    });\n  }\n\n  validateOnlyPermissions() {\n    Promise.all([this.permissionsService.hasPermission(this.ngxPermissionsOnly), this.rolesService.hasOnlyRoles(this.ngxPermissionsOnly)]).then(([hasPermissions, hasRoles]) => {\n      if (hasPermissions || hasRoles) {\n        this.handleAuthorisedPermission(this.ngxPermissionsOnlyThen || this.ngxPermissionsThen || this.templateRef);\n      } else {\n        this.handleUnauthorisedPermission(this.ngxPermissionsOnlyElse || this.ngxPermissionsElse);\n      }\n    }).catch(() => {\n      this.handleUnauthorisedPermission(this.ngxPermissionsOnlyElse || this.ngxPermissionsElse);\n    });\n  }\n\n  handleUnauthorisedPermission(template) {\n    if (isBoolean(this.currentAuthorizedState) && !this.currentAuthorizedState) {\n      return;\n    }\n\n    this.currentAuthorizedState = false;\n    this.permissionsUnauthorized.emit();\n\n    if (this.getUnAuthorizedStrategyInput()) {\n      this.applyStrategyAccordingToStrategyType(this.getUnAuthorizedStrategyInput());\n      return;\n    }\n\n    if (this.configurationService.onUnAuthorisedDefaultStrategy && !this.elseBlockDefined()) {\n      this.applyStrategy(this.configurationService.onUnAuthorisedDefaultStrategy);\n    } else {\n      this.showTemplateBlockInView(template);\n    }\n  }\n\n  handleAuthorisedPermission(template) {\n    if (isBoolean(this.currentAuthorizedState) && this.currentAuthorizedState) {\n      return;\n    }\n\n    this.currentAuthorizedState = true;\n    this.permissionsAuthorized.emit();\n\n    if (this.getAuthorizedStrategyInput()) {\n      this.applyStrategyAccordingToStrategyType(this.getAuthorizedStrategyInput());\n      return;\n    }\n\n    if (this.configurationService.onAuthorisedDefaultStrategy && !this.thenBlockDefined()) {\n      this.applyStrategy(this.configurationService.onAuthorisedDefaultStrategy);\n    } else {\n      this.showTemplateBlockInView(template);\n    }\n  }\n\n  applyStrategyAccordingToStrategyType(strategy) {\n    if (isString(strategy)) {\n      this.applyStrategy(strategy);\n      return;\n    }\n\n    if (isFunction(strategy)) {\n      this.showTemplateBlockInView(this.templateRef);\n      strategy(this.templateRef);\n      return;\n    }\n  }\n\n  showTemplateBlockInView(template) {\n    this.viewContainer.clear();\n\n    if (!template) {\n      return;\n    }\n\n    this.viewContainer.createEmbeddedView(template);\n    this.changeDetector.markForCheck();\n  }\n\n  getAuthorisedTemplates() {\n    return this.ngxPermissionsOnlyThen || this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef;\n  }\n\n  elseBlockDefined() {\n    return !!this.ngxPermissionsExceptElse || !!this.ngxPermissionsElse;\n  }\n\n  thenBlockDefined() {\n    return !!this.ngxPermissionsExceptThen || !!this.ngxPermissionsThen;\n  }\n\n  getAuthorizedStrategyInput() {\n    return this.ngxPermissionsOnlyAuthorisedStrategy || this.ngxPermissionsExceptAuthorisedStrategy || this.ngxPermissionsAuthorisedStrategy;\n  }\n\n  getUnAuthorizedStrategyInput() {\n    return this.ngxPermissionsOnlyUnauthorisedStrategy || this.ngxPermissionsExceptUnauthorisedStrategy || this.ngxPermissionsUnauthorisedStrategy;\n  }\n\n  applyStrategy(name) {\n    if (name === NgxPermissionsPredefinedStrategies.SHOW) {\n      this.showTemplateBlockInView(this.templateRef);\n      return;\n    }\n\n    if (name === NgxPermissionsPredefinedStrategies.REMOVE) {\n      this.viewContainer.clear();\n      return;\n    }\n\n    const strategy = this.configurationService.getStrategy(name);\n    this.showTemplateBlockInView(this.templateRef);\n    strategy(this.templateRef);\n  }\n\n}\n\nNgxPermissionsDirective.ɵfac = function NgxPermissionsDirective_Factory(t) {\n  return new (t || NgxPermissionsDirective)(i0.ɵɵdirectiveInject(NgxPermissionsService), i0.ɵɵdirectiveInject(NgxPermissionsConfigurationService), i0.ɵɵdirectiveInject(NgxRolesService), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.TemplateRef));\n};\n\nNgxPermissionsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: NgxPermissionsDirective,\n  selectors: [[\"\", \"ngxPermissionsOnly\", \"\"], [\"\", \"ngxPermissionsExcept\", \"\"]],\n  inputs: {\n    ngxPermissionsOnly: \"ngxPermissionsOnly\",\n    ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\",\n    ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\",\n    ngxPermissionsExcept: \"ngxPermissionsExcept\",\n    ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\",\n    ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\",\n    ngxPermissionsThen: \"ngxPermissionsThen\",\n    ngxPermissionsElse: \"ngxPermissionsElse\",\n    ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\",\n    ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\",\n    ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\",\n    ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\",\n    ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\",\n    ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\"\n  },\n  outputs: {\n    permissionsAuthorized: \"permissionsAuthorized\",\n    permissionsUnauthorized: \"permissionsUnauthorized\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n    }]\n  }], function () {\n    return [{\n      type: NgxPermissionsService\n    }, {\n      type: NgxPermissionsConfigurationService\n    }, {\n      type: NgxRolesService\n    }, {\n      type: i0.ViewContainerRef\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i0.TemplateRef\n    }];\n  }, {\n    ngxPermissionsOnly: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyThen: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyElse: [{\n      type: Input\n    }],\n    ngxPermissionsExcept: [{\n      type: Input\n    }],\n    ngxPermissionsExceptElse: [{\n      type: Input\n    }],\n    ngxPermissionsExceptThen: [{\n      type: Input\n    }],\n    ngxPermissionsThen: [{\n      type: Input\n    }],\n    ngxPermissionsElse: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsAuthorisedStrategy: [{\n      type: Input\n    }],\n    permissionsAuthorized: [{\n      type: Output\n    }],\n    permissionsUnauthorized: [{\n      type: Output\n    }]\n  });\n})();\n\nconst DEFAULT_REDIRECT_KEY = 'default';\n\nclass NgxPermissionsGuard {\n  constructor(permissionsService, rolesService, router) {\n    this.permissionsService = permissionsService;\n    this.rolesService = rolesService;\n    this.router = router;\n  }\n\n  canActivate(route, state) {\n    return this.hasPermissions(route, state);\n  }\n\n  canActivateChild(childRoute, state) {\n    return this.hasPermissions(childRoute, state);\n  }\n\n  canLoad(route) {\n    return this.hasPermissions(route);\n  }\n\n  hasPermissions(route, state) {\n    const routeDataPermissions = !!route && route.data ? route.data.permissions : {};\n    const permissions = this.transformPermission(routeDataPermissions, route, state);\n\n    if (this.isParameterAvailable(permissions.except)) {\n      return this.passingExceptPermissionsValidation(permissions, route, state);\n    }\n\n    if (this.isParameterAvailable(permissions.only)) {\n      return this.passingOnlyPermissionsValidation(permissions, route, state);\n    }\n\n    return true;\n  }\n\n  transformPermission(permissions, route, state) {\n    const only = isFunction(permissions.only) ? permissions.only(route, state) : transformStringToArray(permissions.only);\n    const except = isFunction(permissions.except) ? permissions.except(route, state) : transformStringToArray(permissions.except);\n    const redirectTo = permissions.redirectTo;\n    return {\n      only,\n      except,\n      redirectTo\n    };\n  }\n\n  isParameterAvailable(permission) {\n    return !!permission && permission.length > 0;\n  }\n\n  passingExceptPermissionsValidation(permissions, route, state) {\n    if (!!permissions.redirectTo && (isFunction(permissions.redirectTo) || isPlainObject(permissions.redirectTo) && !this.isRedirectionWithParameters(permissions.redirectTo))) {\n      let failedPermission = '';\n      return from(permissions.except).pipe(mergeMap(permissionsExcept => {\n        return forkJoin([this.permissionsService.hasPermission(permissionsExcept), this.rolesService.hasOnlyRoles(permissionsExcept)]).pipe(tap(hasPermissions => {\n          const dontHavePermissions = hasPermissions.every(hasPermission => hasPermission === false);\n\n          if (!dontHavePermissions) {\n            failedPermission = permissionsExcept;\n          }\n        }));\n      }), first(hasPermissions => hasPermissions.some(hasPermission => hasPermission === true), false), mergeMap(isAllFalse => {\n        if (!!failedPermission) {\n          this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n          return of(false);\n        }\n\n        if (!isAllFalse && permissions.only) {\n          return this.onlyRedirectCheck(permissions, route, state);\n        }\n\n        return of(!isAllFalse);\n      })).toPromise();\n    }\n\n    return Promise.all([this.permissionsService.hasPermission(permissions.except), this.rolesService.hasOnlyRoles(permissions.except)]).then(([hasPermission, hasRoles]) => {\n      if (hasPermission || hasRoles) {\n        if (permissions.redirectTo) {\n          this.redirectToAnotherRoute(permissions.redirectTo, route, state);\n        }\n\n        return false;\n      }\n\n      if (permissions.only) {\n        return this.checkOnlyPermissions(permissions, route, state);\n      }\n\n      return true;\n    });\n  }\n\n  redirectToAnotherRoute(permissionRedirectTo, route, state, failedPermissionName) {\n    const redirectTo = isFunction(permissionRedirectTo) ? permissionRedirectTo(failedPermissionName, route, state) : permissionRedirectTo;\n\n    if (this.isRedirectionWithParameters(redirectTo)) {\n      redirectTo.navigationCommands = this.transformNavigationCommands(redirectTo.navigationCommands, route, state);\n      redirectTo.navigationExtras = this.transformNavigationExtras(redirectTo.navigationExtras, route, state);\n      this.router.navigate(redirectTo.navigationCommands, redirectTo.navigationExtras);\n      return;\n    }\n\n    if (Array.isArray(redirectTo)) {\n      this.router.navigate(redirectTo);\n    } else {\n      this.router.navigate([redirectTo]);\n    }\n  }\n\n  isRedirectionWithParameters(object) {\n    return isPlainObject(object) && (!!object.navigationCommands || !!object.navigationExtras);\n  }\n\n  transformNavigationCommands(navigationCommands, route, state) {\n    return isFunction(navigationCommands) ? navigationCommands(route, state) : navigationCommands;\n  }\n\n  transformNavigationExtras(navigationExtras, route, state) {\n    return isFunction(navigationExtras) ? navigationExtras(route, state) : navigationExtras;\n  }\n\n  onlyRedirectCheck(permissions, route, state) {\n    let failedPermission = '';\n    return from(permissions.only).pipe(mergeMap(permissionsOnly => {\n      return forkJoin([this.permissionsService.hasPermission(permissionsOnly), this.rolesService.hasOnlyRoles(permissionsOnly)]).pipe(tap(hasPermissions => {\n        const failed = hasPermissions.every(hasPermission => hasPermission === false);\n\n        if (failed) {\n          failedPermission = permissionsOnly;\n        }\n      }));\n    }), first(hasPermissions => {\n      if (isFunction(permissions.redirectTo)) {\n        return hasPermissions.some(hasPermission => hasPermission === true);\n      }\n\n      return hasPermissions.every(hasPermission => hasPermission === false);\n    }, false), mergeMap(pass => {\n      if (isFunction(permissions.redirectTo)) {\n        if (pass) {\n          return of(true);\n        } else {\n          this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n          return of(false);\n        }\n      } else {\n        if (!!failedPermission) {\n          this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n        }\n\n        return of(!pass);\n      }\n    })).toPromise();\n  }\n\n  handleRedirectOfFailedPermission(permissions, failedPermission, route, state) {\n    if (this.isFailedPermissionPropertyOfRedirectTo(permissions, failedPermission)) {\n      this.redirectToAnotherRoute(permissions.redirectTo[failedPermission], route, state, failedPermission);\n    } else {\n      if (isFunction(permissions.redirectTo)) {\n        this.redirectToAnotherRoute(permissions.redirectTo, route, state, failedPermission);\n      } else {\n        this.redirectToAnotherRoute(permissions.redirectTo[DEFAULT_REDIRECT_KEY], route, state, failedPermission);\n      }\n    }\n  }\n\n  isFailedPermissionPropertyOfRedirectTo(permissions, failedPermission) {\n    return !!permissions.redirectTo && permissions.redirectTo[failedPermission];\n  }\n\n  checkOnlyPermissions(purePermissions, route, state) {\n    const permissions = { ...purePermissions\n    };\n    return Promise.all([this.permissionsService.hasPermission(permissions.only), this.rolesService.hasOnlyRoles(permissions.only)]).then(([hasPermission, hasRole]) => {\n      if (hasPermission || hasRole) {\n        return true;\n      }\n\n      if (permissions.redirectTo) {\n        this.redirectToAnotherRoute(permissions.redirectTo, route, state);\n      }\n\n      return false;\n    });\n  }\n\n  passingOnlyPermissionsValidation(permissions, route, state) {\n    if (isFunction(permissions.redirectTo) || isPlainObject(permissions.redirectTo) && !this.isRedirectionWithParameters(permissions.redirectTo)) {\n      return this.onlyRedirectCheck(permissions, route, state);\n    }\n\n    return this.checkOnlyPermissions(permissions, route, state);\n  }\n\n}\n\nNgxPermissionsGuard.ɵfac = function NgxPermissionsGuard_Factory(t) {\n  return new (t || NgxPermissionsGuard)(i0.ɵɵinject(NgxPermissionsService), i0.ɵɵinject(NgxRolesService), i0.ɵɵinject(i3.Router));\n};\n\nNgxPermissionsGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxPermissionsGuard,\n  factory: NgxPermissionsGuard.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsGuard, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: NgxPermissionsService\n    }, {\n      type: NgxRolesService\n    }, {\n      type: i3.Router\n    }];\n  }, null);\n})();\n\nclass NgxPermissionsAllowStubDirective {\n  constructor(viewContainer, templateRef) {\n    this.viewContainer = viewContainer;\n    this.templateRef = templateRef;\n    this.permissionsAuthorized = new EventEmitter();\n    this.permissionsUnauthorized = new EventEmitter();\n  }\n\n  ngOnInit() {\n    this.viewContainer.clear();\n    this.viewContainer.createEmbeddedView(this.getAuthorizedTemplate());\n    this.permissionsUnauthorized.emit();\n  }\n\n  getAuthorizedTemplate() {\n    return this.ngxPermissionsOnlyThen || this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef;\n  }\n\n}\n\nNgxPermissionsAllowStubDirective.ɵfac = function NgxPermissionsAllowStubDirective_Factory(t) {\n  return new (t || NgxPermissionsAllowStubDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.TemplateRef));\n};\n\nNgxPermissionsAllowStubDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: NgxPermissionsAllowStubDirective,\n  selectors: [[\"\", \"ngxPermissionsOnly\", \"\"], [\"\", \"ngxPermissionsExcept\", \"\"]],\n  inputs: {\n    ngxPermissionsOnly: \"ngxPermissionsOnly\",\n    ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\",\n    ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\",\n    ngxPermissionsExcept: \"ngxPermissionsExcept\",\n    ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\",\n    ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\",\n    ngxPermissionsThen: \"ngxPermissionsThen\",\n    ngxPermissionsElse: \"ngxPermissionsElse\",\n    ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\",\n    ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\",\n    ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\",\n    ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\",\n    ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\",\n    ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\"\n  },\n  outputs: {\n    permissionsAuthorized: \"permissionsAuthorized\",\n    permissionsUnauthorized: \"permissionsUnauthorized\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsAllowStubDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ViewContainerRef\n    }, {\n      type: i0.TemplateRef\n    }];\n  }, {\n    ngxPermissionsOnly: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyThen: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyElse: [{\n      type: Input\n    }],\n    ngxPermissionsExcept: [{\n      type: Input\n    }],\n    ngxPermissionsExceptElse: [{\n      type: Input\n    }],\n    ngxPermissionsExceptThen: [{\n      type: Input\n    }],\n    ngxPermissionsThen: [{\n      type: Input\n    }],\n    ngxPermissionsElse: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsAuthorisedStrategy: [{\n      type: Input\n    }],\n    permissionsAuthorized: [{\n      type: Output\n    }],\n    permissionsUnauthorized: [{\n      type: Output\n    }]\n  });\n})();\n\nclass NgxPermissionsRestrictStubDirective {\n  constructor(viewContainer) {\n    this.viewContainer = viewContainer;\n    this.permissionsAuthorized = new EventEmitter();\n    this.permissionsUnauthorized = new EventEmitter();\n  }\n\n  ngOnInit() {\n    this.viewContainer.clear();\n\n    if (this.getUnAuthorizedTemplate()) {\n      this.viewContainer.createEmbeddedView(this.getUnAuthorizedTemplate());\n    }\n\n    this.permissionsUnauthorized.emit();\n  }\n\n  getUnAuthorizedTemplate() {\n    return this.ngxPermissionsOnlyElse || this.ngxPermissionsExceptElse || this.ngxPermissionsElse;\n  }\n\n}\n\nNgxPermissionsRestrictStubDirective.ɵfac = function NgxPermissionsRestrictStubDirective_Factory(t) {\n  return new (t || NgxPermissionsRestrictStubDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n};\n\nNgxPermissionsRestrictStubDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: NgxPermissionsRestrictStubDirective,\n  selectors: [[\"\", \"ngxPermissionsOnly\", \"\"], [\"\", \"ngxPermissionsExcept\", \"\"]],\n  inputs: {\n    ngxPermissionsOnly: \"ngxPermissionsOnly\",\n    ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\",\n    ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\",\n    ngxPermissionsExcept: \"ngxPermissionsExcept\",\n    ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\",\n    ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\",\n    ngxPermissionsThen: \"ngxPermissionsThen\",\n    ngxPermissionsElse: \"ngxPermissionsElse\",\n    ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\",\n    ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\",\n    ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\",\n    ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\",\n    ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\",\n    ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\"\n  },\n  outputs: {\n    permissionsAuthorized: \"permissionsAuthorized\",\n    permissionsUnauthorized: \"permissionsUnauthorized\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsRestrictStubDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ViewContainerRef\n    }];\n  }, {\n    ngxPermissionsOnly: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyThen: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyElse: [{\n      type: Input\n    }],\n    ngxPermissionsExcept: [{\n      type: Input\n    }],\n    ngxPermissionsExceptElse: [{\n      type: Input\n    }],\n    ngxPermissionsExceptThen: [{\n      type: Input\n    }],\n    ngxPermissionsThen: [{\n      type: Input\n    }],\n    ngxPermissionsElse: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsAuthorisedStrategy: [{\n      type: Input\n    }],\n    permissionsAuthorized: [{\n      type: Output\n    }],\n    permissionsUnauthorized: [{\n      type: Output\n    }]\n  });\n})();\n\nclass NgxPermissionsModule {\n  static forRoot(config = {}) {\n    return {\n      ngModule: NgxPermissionsModule,\n      providers: [NgxPermissionsStore, NgxRolesStore, NgxPermissionsConfigurationStore, NgxPermissionsService, NgxPermissionsGuard, NgxRolesService, NgxPermissionsConfigurationService, {\n        provide: USE_PERMISSIONS_STORE,\n        useValue: config.permissionsIsolate\n      }, {\n        provide: USE_ROLES_STORE,\n        useValue: config.rolesIsolate\n      }, {\n        provide: USE_CONFIGURATION_STORE,\n        useValue: config.configurationIsolate\n      }]\n    };\n  }\n\n  static forChild(config = {}) {\n    return {\n      ngModule: NgxPermissionsModule,\n      providers: [{\n        provide: USE_PERMISSIONS_STORE,\n        useValue: config.permissionsIsolate\n      }, {\n        provide: USE_ROLES_STORE,\n        useValue: config.rolesIsolate\n      }, {\n        provide: USE_CONFIGURATION_STORE,\n        useValue: config.configurationIsolate\n      }, NgxPermissionsConfigurationService, NgxPermissionsService, NgxRolesService, NgxPermissionsGuard]\n    };\n  }\n\n}\n\nNgxPermissionsModule.ɵfac = function NgxPermissionsModule_Factory(t) {\n  return new (t || NgxPermissionsModule)();\n};\n\nNgxPermissionsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxPermissionsModule\n});\nNgxPermissionsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsModule, [{\n    type: NgModule,\n    args: [{\n      imports: [],\n      declarations: [NgxPermissionsDirective],\n      exports: [NgxPermissionsDirective]\n    }]\n  }], null, null);\n})();\n\nclass NgxPermissionsAllowStubModule {}\n\nNgxPermissionsAllowStubModule.ɵfac = function NgxPermissionsAllowStubModule_Factory(t) {\n  return new (t || NgxPermissionsAllowStubModule)();\n};\n\nNgxPermissionsAllowStubModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxPermissionsAllowStubModule\n});\nNgxPermissionsAllowStubModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsAllowStubModule, [{\n    type: NgModule,\n    args: [{\n      imports: [],\n      declarations: [NgxPermissionsAllowStubDirective],\n      exports: [NgxPermissionsAllowStubDirective]\n    }]\n  }], null, null);\n})();\n\nclass NgxPermissionsRestrictStubModule {}\n\nNgxPermissionsRestrictStubModule.ɵfac = function NgxPermissionsRestrictStubModule_Factory(t) {\n  return new (t || NgxPermissionsRestrictStubModule)();\n};\n\nNgxPermissionsRestrictStubModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxPermissionsRestrictStubModule\n});\nNgxPermissionsRestrictStubModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsRestrictStubModule, [{\n    type: NgModule,\n    args: [{\n      imports: [],\n      declarations: [NgxPermissionsRestrictStubDirective],\n      exports: [NgxPermissionsRestrictStubDirective]\n    }]\n  }], null, null);\n})();\n/*\n * Public API Surface of ngx-permissions\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DEFAULT_REDIRECT_KEY, NgxPermissionsAllowStubDirective, NgxPermissionsAllowStubModule, NgxPermissionsConfigurationService, NgxPermissionsConfigurationStore, NgxPermissionsDirective, NgxPermissionsGuard, NgxPermissionsModule, NgxPermissionsPredefinedStrategies, NgxPermissionsRestrictStubDirective, NgxPermissionsRestrictStubModule, NgxPermissionsService, NgxPermissionsStore, NgxRolesService, NgxRolesStore, USE_CONFIGURATION_STORE, USE_PERMISSIONS_STORE, USE_ROLES_STORE };","map":{"version":3,"names":["i0","Injectable","InjectionToken","Inject","EventEmitter","Directive","Input","Output","NgModule","BehaviorSubject","of","from","merge","forkJoin","map","switchMap","catchError","mergeAll","first","mergeMap","every","skip","take","tap","i3","NgxPermissionsPredefinedStrategies","REMOVE","SHOW","isFunction","value","isPlainObject","Object","prototype","toString","call","getPrototypeOf","isString","isBoolean","isPromise","promise","notEmptyValue","Array","isArray","length","transformStringToArray","NgxPermissionsStore","constructor","permissionsSource","permissions$","asObservable","ɵfac","ɵprov","type","USE_PERMISSIONS_STORE","NgxPermissionsService","isolate","permissionsStore","flushPermissions","next","hasPermission","permission","Promise","resolve","hasArrayPermission","loadPermissions","permissions","validationFunction","newPermissions","reduce","source","name","reducePermission","addPermission","removePermission","permissionName","getPermission","getPermissions","promises","key","hasPermissionValidationFunction","immutableValue","pipe","data","toPromise","then","undefined","decorators","args","NgxPermissionsConfigurationStore","strategiesSource","strategies$","USE_CONFIGURATION_STORE","NgxPermissionsConfigurationService","configurationStore","onAuthorisedDefaultStrategy","onUnAuthorisedDefaultStrategy","setDefaultOnAuthorizedStrategy","getDefinedStrategy","setDefaultOnUnauthorizedStrategy","addPermissionStrategy","func","getStrategy","getAllStrategies","isPredefinedStrategy","Error","strategy","NgxRolesStore","rolesSource","roles$","USE_ROLES_STORE","NgxRolesService","rolesStore","permissionsService","addRole","roles","addRoleWithPermissions","addRoles","rolesObj","keys","forEach","index","addRolesWithPermissions","flushRoles","flushRolesAndPermissions","removeRole","roleName","getRoles","getRole","hasOnlyRoles","names","isNamesEmpty","all","hasRoleKey","hasRolePermission","hasRoles","hasPermissions","hasValidationFunction","roleNames","NgxPermissionsDirective","configurationService","rolesService","viewContainer","changeDetector","templateRef","permissionsAuthorized","permissionsUnauthorized","firstMergeUnusedRun","ngOnInit","clear","initPermissionSubscription","validateExceptOnlyPermissions","ngOnChanges","changes","onlyChanges","ngxPermissionsOnly","exceptChanges","ngxPermissionsExcept","firstChange","subscribe","validateExceptAndOnlyPermissions","validateOnlyPermissions","handleAuthorisedPermission","getAuthorisedTemplates","ngOnDestroy","unsubscribe","hasRole","handleUnauthorisedPermission","ngxPermissionsExceptElse","ngxPermissionsElse","ngxPermissionsExceptThen","ngxPermissionsThen","catch","ngxPermissionsOnlyThen","ngxPermissionsOnlyElse","template","currentAuthorizedState","emit","getUnAuthorizedStrategyInput","applyStrategyAccordingToStrategyType","elseBlockDefined","applyStrategy","showTemplateBlockInView","getAuthorizedStrategyInput","thenBlockDefined","createEmbeddedView","markForCheck","ngxPermissionsOnlyAuthorisedStrategy","ngxPermissionsExceptAuthorisedStrategy","ngxPermissionsAuthorisedStrategy","ngxPermissionsOnlyUnauthorisedStrategy","ngxPermissionsExceptUnauthorisedStrategy","ngxPermissionsUnauthorisedStrategy","ViewContainerRef","ChangeDetectorRef","TemplateRef","ɵdir","selector","DEFAULT_REDIRECT_KEY","NgxPermissionsGuard","router","canActivate","route","state","canActivateChild","childRoute","canLoad","routeDataPermissions","transformPermission","isParameterAvailable","except","passingExceptPermissionsValidation","only","passingOnlyPermissionsValidation","redirectTo","isRedirectionWithParameters","failedPermission","permissionsExcept","dontHavePermissions","some","isAllFalse","handleRedirectOfFailedPermission","onlyRedirectCheck","redirectToAnotherRoute","checkOnlyPermissions","permissionRedirectTo","failedPermissionName","navigationCommands","transformNavigationCommands","navigationExtras","transformNavigationExtras","navigate","object","permissionsOnly","failed","pass","isFailedPermissionPropertyOfRedirectTo","purePermissions","Router","NgxPermissionsAllowStubDirective","getAuthorizedTemplate","NgxPermissionsRestrictStubDirective","getUnAuthorizedTemplate","NgxPermissionsModule","forRoot","config","ngModule","providers","provide","useValue","permissionsIsolate","rolesIsolate","configurationIsolate","forChild","ɵmod","ɵinj","imports","declarations","exports","NgxPermissionsAllowStubModule","NgxPermissionsRestrictStubModule"],"sources":["C:/Users/Massimo/Desktop/instagram_challenge/node_modules/ngx-permissions/fesm2020/ngx-permissions.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, Inject, EventEmitter, Directive, Input, Output, NgModule } from '@angular/core';\nimport { BehaviorSubject, of, from, merge, forkJoin } from 'rxjs';\nimport { map, switchMap, catchError, mergeAll, first, mergeMap, every, skip, take, tap } from 'rxjs/operators';\nimport * as i3 from '@angular/router';\n\nconst NgxPermissionsPredefinedStrategies = {\n    REMOVE: 'remove',\n    SHOW: 'show'\n};\n\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\nfunction isPlainObject(value) {\n    if (Object.prototype.toString.call(value) !== '[object Object]') {\n        return false;\n    }\n    else {\n        const prototype = Object.getPrototypeOf(value);\n        return prototype === null || prototype === Object.prototype;\n    }\n}\nfunction isString(value) {\n    return !!value && typeof value === 'string';\n}\nfunction isBoolean(value) {\n    return typeof value === 'boolean';\n}\nfunction isPromise(promise) {\n    return Object.prototype.toString.call(promise) === '[object Promise]';\n}\nfunction notEmptyValue(value) {\n    if (Array.isArray(value)) {\n        return value.length > 0;\n    }\n    return !!value;\n}\nfunction transformStringToArray(value) {\n    if (isString(value)) {\n        return [value];\n    }\n    return value;\n}\n\nclass NgxPermissionsStore {\n    constructor() {\n        this.permissionsSource = new BehaviorSubject({});\n        this.permissions$ = this.permissionsSource.asObservable();\n    }\n}\nNgxPermissionsStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nNgxPermissionsStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsStore });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsStore, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return []; } });\n\nconst USE_PERMISSIONS_STORE = new InjectionToken('USE_PERMISSIONS_STORE');\nclass NgxPermissionsService {\n    constructor(isolate = false, permissionsStore) {\n        this.isolate = isolate;\n        this.permissionsStore = permissionsStore;\n        this.permissionsSource = isolate ? new BehaviorSubject({}) : permissionsStore.permissionsSource;\n        this.permissions$ = this.permissionsSource.asObservable();\n    }\n    /**\n     * Remove all permissions from permissions source\n     */\n    flushPermissions() {\n        this.permissionsSource.next({});\n    }\n    hasPermission(permission) {\n        if (!permission || (Array.isArray(permission) && permission.length === 0)) {\n            return Promise.resolve(true);\n        }\n        permission = transformStringToArray(permission);\n        return this.hasArrayPermission(permission);\n    }\n    loadPermissions(permissions, validationFunction) {\n        const newPermissions = permissions.reduce((source, name) => this.reducePermission(source, name, validationFunction), {});\n        this.permissionsSource.next(newPermissions);\n    }\n    addPermission(permission, validationFunction) {\n        if (Array.isArray(permission)) {\n            const permissions = permission.reduce((source, name) => this.reducePermission(source, name, validationFunction), this.permissionsSource.value);\n            this.permissionsSource.next(permissions);\n        }\n        else {\n            const permissions = this.reducePermission(this.permissionsSource.value, permission, validationFunction);\n            this.permissionsSource.next(permissions);\n        }\n    }\n    removePermission(permissionName) {\n        const permissions = {\n            ...this.permissionsSource.value\n        };\n        delete permissions[permissionName];\n        this.permissionsSource.next(permissions);\n    }\n    getPermission(name) {\n        return this.permissionsSource.value[name];\n    }\n    getPermissions() {\n        return this.permissionsSource.value;\n    }\n    reducePermission(source, name, validationFunction) {\n        if (!!validationFunction && isFunction(validationFunction)) {\n            return {\n                ...source,\n                [name]: { name, validationFunction }\n            };\n        }\n        return {\n            ...source,\n            [name]: { name }\n        };\n    }\n    hasArrayPermission(permissions) {\n        const promises = permissions.map(key => {\n            if (this.hasPermissionValidationFunction(key)) {\n                const validationFunction = this.permissionsSource.value[key].validationFunction;\n                const immutableValue = { ...this.permissionsSource.value };\n                return of(null).pipe(map(() => validationFunction(key, immutableValue)), switchMap((promise) => isBoolean(promise) ?\n                    of(promise) : promise), catchError(() => of(false)));\n            }\n            // check for name of the permission if there is no validation function\n            return of(!!this.permissionsSource.value[key]);\n        });\n        return from(promises).pipe(mergeAll(), first((data) => data !== false, false), map((data) => data !== false)).toPromise().then((data) => data);\n    }\n    hasPermissionValidationFunction(key) {\n        return !!this.permissionsSource.value[key] &&\n            !!this.permissionsSource.value[key].validationFunction &&\n            isFunction(this.permissionsSource.value[key].validationFunction);\n    }\n}\nNgxPermissionsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsService, deps: [{ token: USE_PERMISSIONS_STORE }, { token: NgxPermissionsStore }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxPermissionsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [USE_PERMISSIONS_STORE]\n                }] }, { type: NgxPermissionsStore }]; } });\n\nclass NgxPermissionsConfigurationStore {\n    constructor() {\n        this.strategiesSource = new BehaviorSubject({});\n        this.strategies$ = this.strategiesSource.asObservable();\n    }\n}\nNgxPermissionsConfigurationStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsConfigurationStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nNgxPermissionsConfigurationStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsConfigurationStore });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsConfigurationStore, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return []; } });\n\nconst USE_CONFIGURATION_STORE = new InjectionToken('USE_CONFIGURATION_STORE');\nclass NgxPermissionsConfigurationService {\n    constructor(isolate = false, configurationStore) {\n        this.isolate = isolate;\n        this.configurationStore = configurationStore;\n        this.strategiesSource = this.isolate ? new BehaviorSubject({}) : this.configurationStore.strategiesSource;\n        this.strategies$ = this.strategiesSource.asObservable();\n        this.onAuthorisedDefaultStrategy = this.isolate ? undefined : this.configurationStore.onAuthorisedDefaultStrategy;\n        this.onUnAuthorisedDefaultStrategy = this.isolate ? undefined : this.configurationStore.onUnAuthorisedDefaultStrategy;\n    }\n    setDefaultOnAuthorizedStrategy(name) {\n        if (this.isolate) {\n            this.onAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n        }\n        else {\n            this.configurationStore.onAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n            this.onAuthorisedDefaultStrategy = this.configurationStore.onAuthorisedDefaultStrategy;\n        }\n    }\n    setDefaultOnUnauthorizedStrategy(name) {\n        if (this.isolate) {\n            this.onUnAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n        }\n        else {\n            this.configurationStore.onUnAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n            this.onUnAuthorisedDefaultStrategy = this.configurationStore.onUnAuthorisedDefaultStrategy;\n        }\n    }\n    addPermissionStrategy(key, func) {\n        this.strategiesSource.value[key] = func;\n    }\n    getStrategy(key) {\n        return this.strategiesSource.value[key];\n    }\n    getAllStrategies() {\n        return this.strategiesSource.value;\n    }\n    getDefinedStrategy(name) {\n        if (this.strategiesSource.value[name] || this.isPredefinedStrategy(name)) {\n            return name;\n        }\n        else {\n            throw new Error(`No ' ${name} ' strategy is found please define one`);\n        }\n    }\n    isPredefinedStrategy(strategy) {\n        return strategy === NgxPermissionsPredefinedStrategies.SHOW || strategy === NgxPermissionsPredefinedStrategies.REMOVE;\n    }\n}\nNgxPermissionsConfigurationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsConfigurationService, deps: [{ token: USE_CONFIGURATION_STORE }, { token: NgxPermissionsConfigurationStore }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxPermissionsConfigurationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsConfigurationService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsConfigurationService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [USE_CONFIGURATION_STORE]\n                }] }, { type: NgxPermissionsConfigurationStore }]; } });\n\nclass NgxRolesStore {\n    constructor() {\n        this.rolesSource = new BehaviorSubject({});\n        this.roles$ = this.rolesSource.asObservable();\n    }\n}\n\nconst USE_ROLES_STORE = new InjectionToken('USE_ROLES_STORE');\nclass NgxRolesService {\n    constructor(isolate = false, rolesStore, permissionsService) {\n        this.isolate = isolate;\n        this.rolesStore = rolesStore;\n        this.permissionsService = permissionsService;\n        this.rolesSource = this.isolate ? new BehaviorSubject({}) : this.rolesStore.rolesSource;\n        this.roles$ = this.rolesSource.asObservable();\n    }\n    addRole(name, validationFunction) {\n        const roles = {\n            ...this.rolesSource.value,\n            [name]: { name, validationFunction }\n        };\n        this.rolesSource.next(roles);\n    }\n    addRoleWithPermissions(name, permissions) {\n        this.permissionsService.addPermission(permissions);\n        this.addRole(name, permissions);\n    }\n    addRoles(rolesObj) {\n        Object.keys(rolesObj).forEach((key, index) => {\n            this.addRole(key, rolesObj[key]);\n        });\n    }\n    addRolesWithPermissions(rolesObj) {\n        Object.keys(rolesObj).forEach((key, index) => {\n            this.addRoleWithPermissions(key, rolesObj[key]);\n        });\n    }\n    flushRoles() {\n        this.rolesSource.next({});\n    }\n    flushRolesAndPermissions() {\n        this.flushRoles();\n        this.permissionsService.flushPermissions();\n    }\n    removeRole(roleName) {\n        const roles = {\n            ...this.rolesSource.value\n        };\n        delete roles[roleName];\n        this.rolesSource.next(roles);\n    }\n    getRoles() {\n        return this.rolesSource.value;\n    }\n    getRole(name) {\n        return this.rolesSource.value[name];\n    }\n    hasOnlyRoles(names) {\n        const isNamesEmpty = !names || (Array.isArray(names) && names.length === 0);\n        if (isNamesEmpty) {\n            return Promise.resolve(true);\n        }\n        names = transformStringToArray(names);\n        return Promise.all([this.hasRoleKey(names), this.hasRolePermission(this.rolesSource.value, names)])\n            .then(([hasRoles, hasPermissions]) => {\n            return hasRoles || hasPermissions;\n        });\n    }\n    hasRoleKey(roleName) {\n        const promises = roleName.map((key) => {\n            const hasValidationFunction = !!this.rolesSource.value[key] &&\n                !!this.rolesSource.value[key].validationFunction &&\n                isFunction(this.rolesSource.value[key].validationFunction);\n            if (hasValidationFunction && !isPromise(this.rolesSource.value[key].validationFunction)) {\n                const validationFunction = this.rolesSource.value[key].validationFunction;\n                const immutableValue = { ...this.rolesSource.value };\n                return of(null).pipe(map(() => validationFunction(key, immutableValue)), switchMap((promise) => isBoolean(promise) ?\n                    of(promise) : promise), catchError(() => of(false)));\n            }\n            return of(false);\n        });\n        return from(promises).pipe(mergeAll(), first((data) => data !== false, false), map((data) => data !== false)).toPromise().then((data) => data);\n    }\n    hasRolePermission(roles, roleNames) {\n        return from(roleNames).pipe(mergeMap((key) => {\n            if (roles[key] && Array.isArray(roles[key].validationFunction)) {\n                return from(roles[key].validationFunction).pipe(mergeMap((permission) => this.permissionsService.hasPermission(permission)), every(hasPermission => hasPermission === true));\n            }\n            return of(false);\n        }), first(hasPermission => hasPermission === true, false)).toPromise();\n    }\n}\nNgxRolesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxRolesService, deps: [{ token: USE_ROLES_STORE }, { token: NgxRolesStore }, { token: NgxPermissionsService }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxRolesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxRolesService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxRolesService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [USE_ROLES_STORE]\n                }] }, { type: NgxRolesStore }, { type: NgxPermissionsService }]; } });\n\nclass NgxPermissionsDirective {\n    constructor(permissionsService, configurationService, rolesService, viewContainer, changeDetector, templateRef) {\n        this.permissionsService = permissionsService;\n        this.configurationService = configurationService;\n        this.rolesService = rolesService;\n        this.viewContainer = viewContainer;\n        this.changeDetector = changeDetector;\n        this.templateRef = templateRef;\n        this.permissionsAuthorized = new EventEmitter();\n        this.permissionsUnauthorized = new EventEmitter();\n        // skip first run cause merge will fire twice\n        this.firstMergeUnusedRun = 1;\n    }\n    ngOnInit() {\n        this.viewContainer.clear();\n        this.initPermissionSubscription = this.validateExceptOnlyPermissions();\n    }\n    ngOnChanges(changes) {\n        const onlyChanges = changes.ngxPermissionsOnly;\n        const exceptChanges = changes.ngxPermissionsExcept;\n        if (onlyChanges || exceptChanges) {\n            // Due to bug when you pass empty array\n            if (onlyChanges && onlyChanges.firstChange) {\n                return;\n            }\n            if (exceptChanges && exceptChanges.firstChange) {\n                return;\n            }\n            merge(this.permissionsService.permissions$, this.rolesService.roles$)\n                .pipe(skip(this.firstMergeUnusedRun), take(1))\n                .subscribe(() => {\n                if (notEmptyValue(this.ngxPermissionsExcept)) {\n                    this.validateExceptAndOnlyPermissions();\n                    return;\n                }\n                if (notEmptyValue(this.ngxPermissionsOnly)) {\n                    this.validateOnlyPermissions();\n                    return;\n                }\n                this.handleAuthorisedPermission(this.getAuthorisedTemplates());\n            });\n        }\n    }\n    ngOnDestroy() {\n        if (this.initPermissionSubscription) {\n            this.initPermissionSubscription.unsubscribe();\n        }\n    }\n    validateExceptOnlyPermissions() {\n        return merge(this.permissionsService.permissions$, this.rolesService.roles$)\n            .pipe(skip(this.firstMergeUnusedRun))\n            .subscribe(() => {\n            if (notEmptyValue(this.ngxPermissionsExcept)) {\n                this.validateExceptAndOnlyPermissions();\n                return;\n            }\n            if (notEmptyValue(this.ngxPermissionsOnly)) {\n                this.validateOnlyPermissions();\n                return;\n            }\n            this.handleAuthorisedPermission(this.getAuthorisedTemplates());\n        });\n    }\n    validateExceptAndOnlyPermissions() {\n        Promise\n            .all([\n            this.permissionsService.hasPermission(this.ngxPermissionsExcept),\n            this.rolesService.hasOnlyRoles(this.ngxPermissionsExcept)\n        ])\n            .then(([hasPermission, hasRole]) => {\n            if (hasPermission || hasRole) {\n                this.handleUnauthorisedPermission(this.ngxPermissionsExceptElse || this.ngxPermissionsElse);\n                return;\n            }\n            if (!!this.ngxPermissionsOnly) {\n                throw false;\n            }\n            this.handleAuthorisedPermission(this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef);\n        })\n            .catch(() => {\n            if (!!this.ngxPermissionsOnly) {\n                this.validateOnlyPermissions();\n            }\n            else {\n                this.handleAuthorisedPermission(this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef);\n            }\n        });\n    }\n    validateOnlyPermissions() {\n        Promise\n            .all([this.permissionsService.hasPermission(this.ngxPermissionsOnly), this.rolesService.hasOnlyRoles(this.ngxPermissionsOnly)])\n            .then(([hasPermissions, hasRoles]) => {\n            if (hasPermissions || hasRoles) {\n                this.handleAuthorisedPermission(this.ngxPermissionsOnlyThen || this.ngxPermissionsThen || this.templateRef);\n            }\n            else {\n                this.handleUnauthorisedPermission(this.ngxPermissionsOnlyElse || this.ngxPermissionsElse);\n            }\n        })\n            .catch(() => {\n            this.handleUnauthorisedPermission(this.ngxPermissionsOnlyElse || this.ngxPermissionsElse);\n        });\n    }\n    handleUnauthorisedPermission(template) {\n        if (isBoolean(this.currentAuthorizedState) && !this.currentAuthorizedState) {\n            return;\n        }\n        this.currentAuthorizedState = false;\n        this.permissionsUnauthorized.emit();\n        if (this.getUnAuthorizedStrategyInput()) {\n            this.applyStrategyAccordingToStrategyType(this.getUnAuthorizedStrategyInput());\n            return;\n        }\n        if (this.configurationService.onUnAuthorisedDefaultStrategy && !this.elseBlockDefined()) {\n            this.applyStrategy(this.configurationService.onUnAuthorisedDefaultStrategy);\n        }\n        else {\n            this.showTemplateBlockInView(template);\n        }\n    }\n    handleAuthorisedPermission(template) {\n        if (isBoolean(this.currentAuthorizedState) && this.currentAuthorizedState) {\n            return;\n        }\n        this.currentAuthorizedState = true;\n        this.permissionsAuthorized.emit();\n        if (this.getAuthorizedStrategyInput()) {\n            this.applyStrategyAccordingToStrategyType(this.getAuthorizedStrategyInput());\n            return;\n        }\n        if (this.configurationService.onAuthorisedDefaultStrategy && !this.thenBlockDefined()) {\n            this.applyStrategy(this.configurationService.onAuthorisedDefaultStrategy);\n        }\n        else {\n            this.showTemplateBlockInView(template);\n        }\n    }\n    applyStrategyAccordingToStrategyType(strategy) {\n        if (isString(strategy)) {\n            this.applyStrategy(strategy);\n            return;\n        }\n        if (isFunction(strategy)) {\n            this.showTemplateBlockInView(this.templateRef);\n            strategy(this.templateRef);\n            return;\n        }\n    }\n    showTemplateBlockInView(template) {\n        this.viewContainer.clear();\n        if (!template) {\n            return;\n        }\n        this.viewContainer.createEmbeddedView(template);\n        this.changeDetector.markForCheck();\n    }\n    getAuthorisedTemplates() {\n        return this.ngxPermissionsOnlyThen\n            || this.ngxPermissionsExceptThen\n            || this.ngxPermissionsThen\n            || this.templateRef;\n    }\n    elseBlockDefined() {\n        return !!this.ngxPermissionsExceptElse || !!this.ngxPermissionsElse;\n    }\n    thenBlockDefined() {\n        return !!this.ngxPermissionsExceptThen || !!this.ngxPermissionsThen;\n    }\n    getAuthorizedStrategyInput() {\n        return this.ngxPermissionsOnlyAuthorisedStrategy ||\n            this.ngxPermissionsExceptAuthorisedStrategy ||\n            this.ngxPermissionsAuthorisedStrategy;\n    }\n    getUnAuthorizedStrategyInput() {\n        return this.ngxPermissionsOnlyUnauthorisedStrategy ||\n            this.ngxPermissionsExceptUnauthorisedStrategy ||\n            this.ngxPermissionsUnauthorisedStrategy;\n    }\n    applyStrategy(name) {\n        if (name === NgxPermissionsPredefinedStrategies.SHOW) {\n            this.showTemplateBlockInView(this.templateRef);\n            return;\n        }\n        if (name === NgxPermissionsPredefinedStrategies.REMOVE) {\n            this.viewContainer.clear();\n            return;\n        }\n        const strategy = this.configurationService.getStrategy(name);\n        this.showTemplateBlockInView(this.templateRef);\n        strategy(this.templateRef);\n    }\n}\nNgxPermissionsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsDirective, deps: [{ token: NgxPermissionsService }, { token: NgxPermissionsConfigurationService }, { token: NgxRolesService }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });\nNgxPermissionsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.0.2\", type: NgxPermissionsDirective, selector: \"[ngxPermissionsOnly],[ngxPermissionsExcept]\", inputs: { ngxPermissionsOnly: \"ngxPermissionsOnly\", ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\", ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\", ngxPermissionsExcept: \"ngxPermissionsExcept\", ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\", ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\", ngxPermissionsThen: \"ngxPermissionsThen\", ngxPermissionsElse: \"ngxPermissionsElse\", ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\", ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\", ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\", ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\", ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\", ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\" }, outputs: { permissionsAuthorized: \"permissionsAuthorized\", permissionsUnauthorized: \"permissionsUnauthorized\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n                }]\n        }], ctorParameters: function () { return [{ type: NgxPermissionsService }, { type: NgxPermissionsConfigurationService }, { type: NgxRolesService }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i0.TemplateRef }]; }, propDecorators: { ngxPermissionsOnly: [{\n                type: Input\n            }], ngxPermissionsOnlyThen: [{\n                type: Input\n            }], ngxPermissionsOnlyElse: [{\n                type: Input\n            }], ngxPermissionsExcept: [{\n                type: Input\n            }], ngxPermissionsExceptElse: [{\n                type: Input\n            }], ngxPermissionsExceptThen: [{\n                type: Input\n            }], ngxPermissionsThen: [{\n                type: Input\n            }], ngxPermissionsElse: [{\n                type: Input\n            }], ngxPermissionsOnlyAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsOnlyUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsAuthorisedStrategy: [{\n                type: Input\n            }], permissionsAuthorized: [{\n                type: Output\n            }], permissionsUnauthorized: [{\n                type: Output\n            }] } });\n\nconst DEFAULT_REDIRECT_KEY = 'default';\n\nclass NgxPermissionsGuard {\n    constructor(permissionsService, rolesService, router) {\n        this.permissionsService = permissionsService;\n        this.rolesService = rolesService;\n        this.router = router;\n    }\n    canActivate(route, state) {\n        return this.hasPermissions(route, state);\n    }\n    canActivateChild(childRoute, state) {\n        return this.hasPermissions(childRoute, state);\n    }\n    canLoad(route) {\n        return this.hasPermissions(route);\n    }\n    hasPermissions(route, state) {\n        const routeDataPermissions = !!route && route.data ? route.data.permissions : {};\n        const permissions = this.transformPermission(routeDataPermissions, route, state);\n        if (this.isParameterAvailable(permissions.except)) {\n            return this.passingExceptPermissionsValidation(permissions, route, state);\n        }\n        if (this.isParameterAvailable(permissions.only)) {\n            return this.passingOnlyPermissionsValidation(permissions, route, state);\n        }\n        return true;\n    }\n    transformPermission(permissions, route, state) {\n        const only = isFunction(permissions.only)\n            ? permissions.only(route, state)\n            : transformStringToArray(permissions.only);\n        const except = isFunction(permissions.except)\n            ? permissions.except(route, state)\n            : transformStringToArray(permissions.except);\n        const redirectTo = permissions.redirectTo;\n        return {\n            only,\n            except,\n            redirectTo\n        };\n    }\n    isParameterAvailable(permission) {\n        return !!permission && permission.length > 0;\n    }\n    passingExceptPermissionsValidation(permissions, route, state) {\n        if (!!permissions.redirectTo\n            && ((isFunction(permissions.redirectTo))\n                || (isPlainObject(permissions.redirectTo) && !this.isRedirectionWithParameters(permissions.redirectTo)))) {\n            let failedPermission = '';\n            return from(permissions.except)\n                .pipe(mergeMap(permissionsExcept => {\n                return forkJoin([\n                    this.permissionsService.hasPermission(permissionsExcept),\n                    this.rolesService.hasOnlyRoles(permissionsExcept)\n                ]).pipe(tap(hasPermissions => {\n                    const dontHavePermissions = hasPermissions.every(hasPermission => hasPermission === false);\n                    if (!dontHavePermissions) {\n                        failedPermission = permissionsExcept;\n                    }\n                }));\n            }), first(hasPermissions => hasPermissions.some(hasPermission => hasPermission === true), false), mergeMap(isAllFalse => {\n                if (!!failedPermission) {\n                    this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n                    return of(false);\n                }\n                if (!isAllFalse && permissions.only) {\n                    return this.onlyRedirectCheck(permissions, route, state);\n                }\n                return of(!isAllFalse);\n            }))\n                .toPromise();\n        }\n        return Promise.all([\n            this.permissionsService.hasPermission(permissions.except),\n            this.rolesService.hasOnlyRoles(permissions.except)\n        ]).then(([hasPermission, hasRoles]) => {\n            if (hasPermission || hasRoles) {\n                if (permissions.redirectTo) {\n                    this.redirectToAnotherRoute(permissions.redirectTo, route, state);\n                }\n                return false;\n            }\n            if (permissions.only) {\n                return this.checkOnlyPermissions(permissions, route, state);\n            }\n            return true;\n        });\n    }\n    redirectToAnotherRoute(permissionRedirectTo, route, state, failedPermissionName) {\n        const redirectTo = isFunction(permissionRedirectTo)\n            ? permissionRedirectTo(failedPermissionName, route, state)\n            : permissionRedirectTo;\n        if (this.isRedirectionWithParameters(redirectTo)) {\n            redirectTo.navigationCommands = this.transformNavigationCommands(redirectTo.navigationCommands, route, state);\n            redirectTo.navigationExtras = this.transformNavigationExtras(redirectTo.navigationExtras, route, state);\n            this.router.navigate(redirectTo.navigationCommands, redirectTo.navigationExtras);\n            return;\n        }\n        if (Array.isArray(redirectTo)) {\n            this.router.navigate(redirectTo);\n        }\n        else {\n            this.router.navigate([redirectTo]);\n        }\n    }\n    isRedirectionWithParameters(object) {\n        return (isPlainObject(object) && (!!object.navigationCommands || !!object.navigationExtras));\n    }\n    transformNavigationCommands(navigationCommands, route, state) {\n        return isFunction(navigationCommands)\n            ? navigationCommands(route, state)\n            : navigationCommands;\n    }\n    transformNavigationExtras(navigationExtras, route, state) {\n        return isFunction(navigationExtras)\n            ? navigationExtras(route, state)\n            : navigationExtras;\n    }\n    onlyRedirectCheck(permissions, route, state) {\n        let failedPermission = '';\n        return from(permissions.only)\n            .pipe(mergeMap(permissionsOnly => {\n            return forkJoin([\n                this.permissionsService.hasPermission(permissionsOnly),\n                this.rolesService.hasOnlyRoles(permissionsOnly)\n            ]).pipe(tap(hasPermissions => {\n                const failed = hasPermissions.every(hasPermission => hasPermission === false);\n                if (failed) {\n                    failedPermission = permissionsOnly;\n                }\n            }));\n        }), first(hasPermissions => {\n            if (isFunction(permissions.redirectTo)) {\n                return hasPermissions.some(hasPermission => hasPermission === true);\n            }\n            return hasPermissions.every(hasPermission => hasPermission === false);\n        }, false), mergeMap((pass) => {\n            if (isFunction(permissions.redirectTo)) {\n                if (pass) {\n                    return of(true);\n                }\n                else {\n                    this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n                    return of(false);\n                }\n            }\n            else {\n                if (!!failedPermission) {\n                    this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n                }\n                return of(!pass);\n            }\n        }))\n            .toPromise();\n    }\n    handleRedirectOfFailedPermission(permissions, failedPermission, route, state) {\n        if (this.isFailedPermissionPropertyOfRedirectTo(permissions, failedPermission)) {\n            this.redirectToAnotherRoute(permissions.redirectTo[failedPermission], route, state, failedPermission);\n        }\n        else {\n            if (isFunction(permissions.redirectTo)) {\n                this.redirectToAnotherRoute(permissions.redirectTo, route, state, failedPermission);\n            }\n            else {\n                this.redirectToAnotherRoute(permissions.redirectTo[DEFAULT_REDIRECT_KEY], route, state, failedPermission);\n            }\n        }\n    }\n    isFailedPermissionPropertyOfRedirectTo(permissions, failedPermission) {\n        return (!!permissions.redirectTo && permissions.redirectTo[failedPermission]);\n    }\n    checkOnlyPermissions(purePermissions, route, state) {\n        const permissions = {\n            ...purePermissions\n        };\n        return Promise.all([\n            this.permissionsService.hasPermission(permissions.only),\n            this.rolesService.hasOnlyRoles(permissions.only)\n        ]).then(([hasPermission, hasRole]) => {\n            if (hasPermission || hasRole) {\n                return true;\n            }\n            if (permissions.redirectTo) {\n                this.redirectToAnotherRoute(permissions.redirectTo, route, state);\n            }\n            return false;\n        });\n    }\n    passingOnlyPermissionsValidation(permissions, route, state) {\n        if ((isFunction(permissions.redirectTo)\n            || isPlainObject(permissions.redirectTo) && !this.isRedirectionWithParameters(permissions.redirectTo))) {\n            return this.onlyRedirectCheck(permissions, route, state);\n        }\n        return this.checkOnlyPermissions(permissions, route, state);\n    }\n}\nNgxPermissionsGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsGuard, deps: [{ token: NgxPermissionsService }, { token: NgxRolesService }, { token: i3.Router }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxPermissionsGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsGuard });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsGuard, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: NgxPermissionsService }, { type: NgxRolesService }, { type: i3.Router }]; } });\n\nclass NgxPermissionsAllowStubDirective {\n    constructor(viewContainer, templateRef) {\n        this.viewContainer = viewContainer;\n        this.templateRef = templateRef;\n        this.permissionsAuthorized = new EventEmitter();\n        this.permissionsUnauthorized = new EventEmitter();\n    }\n    ngOnInit() {\n        this.viewContainer.clear();\n        this.viewContainer.createEmbeddedView(this.getAuthorizedTemplate());\n        this.permissionsUnauthorized.emit();\n    }\n    getAuthorizedTemplate() {\n        return this.ngxPermissionsOnlyThen ||\n            this.ngxPermissionsExceptThen ||\n            this.ngxPermissionsThen ||\n            this.templateRef;\n    }\n}\nNgxPermissionsAllowStubDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsAllowStubDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });\nNgxPermissionsAllowStubDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.0.2\", type: NgxPermissionsAllowStubDirective, selector: \"[ngxPermissionsOnly],[ngxPermissionsExcept]\", inputs: { ngxPermissionsOnly: \"ngxPermissionsOnly\", ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\", ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\", ngxPermissionsExcept: \"ngxPermissionsExcept\", ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\", ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\", ngxPermissionsThen: \"ngxPermissionsThen\", ngxPermissionsElse: \"ngxPermissionsElse\", ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\", ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\", ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\", ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\", ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\", ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\" }, outputs: { permissionsAuthorized: \"permissionsAuthorized\", permissionsUnauthorized: \"permissionsUnauthorized\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsAllowStubDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }]; }, propDecorators: { ngxPermissionsOnly: [{\n                type: Input\n            }], ngxPermissionsOnlyThen: [{\n                type: Input\n            }], ngxPermissionsOnlyElse: [{\n                type: Input\n            }], ngxPermissionsExcept: [{\n                type: Input\n            }], ngxPermissionsExceptElse: [{\n                type: Input\n            }], ngxPermissionsExceptThen: [{\n                type: Input\n            }], ngxPermissionsThen: [{\n                type: Input\n            }], ngxPermissionsElse: [{\n                type: Input\n            }], ngxPermissionsOnlyAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsOnlyUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsAuthorisedStrategy: [{\n                type: Input\n            }], permissionsAuthorized: [{\n                type: Output\n            }], permissionsUnauthorized: [{\n                type: Output\n            }] } });\n\nclass NgxPermissionsRestrictStubDirective {\n    constructor(viewContainer) {\n        this.viewContainer = viewContainer;\n        this.permissionsAuthorized = new EventEmitter();\n        this.permissionsUnauthorized = new EventEmitter();\n    }\n    ngOnInit() {\n        this.viewContainer.clear();\n        if (this.getUnAuthorizedTemplate()) {\n            this.viewContainer.createEmbeddedView(this.getUnAuthorizedTemplate());\n        }\n        this.permissionsUnauthorized.emit();\n    }\n    getUnAuthorizedTemplate() {\n        return this.ngxPermissionsOnlyElse ||\n            this.ngxPermissionsExceptElse ||\n            this.ngxPermissionsElse;\n    }\n}\nNgxPermissionsRestrictStubDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsRestrictStubDirective, deps: [{ token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });\nNgxPermissionsRestrictStubDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.0.2\", type: NgxPermissionsRestrictStubDirective, selector: \"[ngxPermissionsOnly],[ngxPermissionsExcept]\", inputs: { ngxPermissionsOnly: \"ngxPermissionsOnly\", ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\", ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\", ngxPermissionsExcept: \"ngxPermissionsExcept\", ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\", ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\", ngxPermissionsThen: \"ngxPermissionsThen\", ngxPermissionsElse: \"ngxPermissionsElse\", ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\", ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\", ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\", ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\", ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\", ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\" }, outputs: { permissionsAuthorized: \"permissionsAuthorized\", permissionsUnauthorized: \"permissionsUnauthorized\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsRestrictStubDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }]; }, propDecorators: { ngxPermissionsOnly: [{\n                type: Input\n            }], ngxPermissionsOnlyThen: [{\n                type: Input\n            }], ngxPermissionsOnlyElse: [{\n                type: Input\n            }], ngxPermissionsExcept: [{\n                type: Input\n            }], ngxPermissionsExceptElse: [{\n                type: Input\n            }], ngxPermissionsExceptThen: [{\n                type: Input\n            }], ngxPermissionsThen: [{\n                type: Input\n            }], ngxPermissionsElse: [{\n                type: Input\n            }], ngxPermissionsOnlyAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsOnlyUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsAuthorisedStrategy: [{\n                type: Input\n            }], permissionsAuthorized: [{\n                type: Output\n            }], permissionsUnauthorized: [{\n                type: Output\n            }] } });\n\nclass NgxPermissionsModule {\n    static forRoot(config = {}) {\n        return {\n            ngModule: NgxPermissionsModule,\n            providers: [\n                NgxPermissionsStore,\n                NgxRolesStore,\n                NgxPermissionsConfigurationStore,\n                NgxPermissionsService,\n                NgxPermissionsGuard,\n                NgxRolesService,\n                NgxPermissionsConfigurationService,\n                { provide: USE_PERMISSIONS_STORE, useValue: config.permissionsIsolate },\n                { provide: USE_ROLES_STORE, useValue: config.rolesIsolate },\n                { provide: USE_CONFIGURATION_STORE, useValue: config.configurationIsolate },\n            ]\n        };\n    }\n    static forChild(config = {}) {\n        return {\n            ngModule: NgxPermissionsModule,\n            providers: [\n                { provide: USE_PERMISSIONS_STORE, useValue: config.permissionsIsolate },\n                { provide: USE_ROLES_STORE, useValue: config.rolesIsolate },\n                { provide: USE_CONFIGURATION_STORE, useValue: config.configurationIsolate },\n                NgxPermissionsConfigurationService,\n                NgxPermissionsService,\n                NgxRolesService,\n                NgxPermissionsGuard\n            ]\n        };\n    }\n}\nNgxPermissionsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxPermissionsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsModule, declarations: [NgxPermissionsDirective], exports: [NgxPermissionsDirective] });\nNgxPermissionsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsModule, imports: [[]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [],\n                    declarations: [\n                        NgxPermissionsDirective\n                    ],\n                    exports: [\n                        NgxPermissionsDirective\n                    ]\n                }]\n        }] });\nclass NgxPermissionsAllowStubModule {\n}\nNgxPermissionsAllowStubModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsAllowStubModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxPermissionsAllowStubModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsAllowStubModule, declarations: [NgxPermissionsAllowStubDirective], exports: [NgxPermissionsAllowStubDirective] });\nNgxPermissionsAllowStubModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsAllowStubModule, imports: [[]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsAllowStubModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [],\n                    declarations: [\n                        NgxPermissionsAllowStubDirective\n                    ],\n                    exports: [\n                        NgxPermissionsAllowStubDirective\n                    ]\n                }]\n        }] });\nclass NgxPermissionsRestrictStubModule {\n}\nNgxPermissionsRestrictStubModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsRestrictStubModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxPermissionsRestrictStubModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsRestrictStubModule, declarations: [NgxPermissionsRestrictStubDirective], exports: [NgxPermissionsRestrictStubDirective] });\nNgxPermissionsRestrictStubModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsRestrictStubModule, imports: [[]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsRestrictStubModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [],\n                    declarations: [\n                        NgxPermissionsRestrictStubDirective\n                    ],\n                    exports: [\n                        NgxPermissionsRestrictStubDirective\n                    ]\n                }]\n        }] });\n\n/*\n * Public API Surface of ngx-permissions\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DEFAULT_REDIRECT_KEY, NgxPermissionsAllowStubDirective, NgxPermissionsAllowStubModule, NgxPermissionsConfigurationService, NgxPermissionsConfigurationStore, NgxPermissionsDirective, NgxPermissionsGuard, NgxPermissionsModule, NgxPermissionsPredefinedStrategies, NgxPermissionsRestrictStubDirective, NgxPermissionsRestrictStubModule, NgxPermissionsService, NgxPermissionsStore, NgxRolesService, NgxRolesStore, USE_CONFIGURATION_STORE, USE_PERMISSIONS_STORE, USE_ROLES_STORE };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}